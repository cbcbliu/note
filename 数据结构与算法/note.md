# 数据结构

1. 线性结构：数组、队列、链表、栈
2. 非线性结构：二维数组、多维数组、广义表、**树**、**图**

## 稀疏数组

- 基本介绍：当一个数组中大部分元素为0，或者为同一个值时，可以使用稀疏数组来保存该数组。
- 稀疏数组的处理方法：
  1. 记录数组一共有几行几列，有多少个不同的值
  2. 把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模
  ![img](../img/arr2.png)

## 队列(Queue)

- 基本介绍：
  1. 队列是一个有序列表，可以用数组或者链表实现
  2. 遵循**先入先出**的原则。即先入队列的数据要先取出，后存入的要后取出。

## 链表(Linked List)

- 链表是有序地列表，以节点方式存储，每个节点包含数据以及下一个节点的地址。特点：不连续存储
- 链表分为带头节点的和不带头节点
- 经典题目：
  1. 翻转单链表(使用头插法)
  2. 逆序打印单链表(使用栈)
- 约瑟夫(Josephu)问题：设编号为1，2，3，...n的n个人围坐一圈，约定编号为k(1<=k<=n)的人从1开始报数，数到m的那个人出列，他的下一位  
又从1开始报数，数到m又出列，以此类推。直到所有人出列为止，由此产生一个出队编号的序列。使用环形链表解决。

## 栈(Stack)

- 栈是一个先入后出的有序列表
- 栈是限制性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的一段称为栈顶，另一端称为栈底。
- 出栈：push，入栈：pop
### 栈的应用场景
- 子程序调用、处理递归调用、表达式的转换(中缀表达式转后缀表达式)与求值、二叉树的遍历、图形的深度优先搜索法




## 树(Tree)

### 为什么需要树这种结构

1. 数组存储方式的分析  
    优点：通过下标方式访问元素，速度快。**对于有序数组**，还可以使用二分查找提高检索速度。  
    缺点：如果要检索具体某个值，或者插入值(按一定顺序)会整体移动，效率较低。
2. 链式存储方式的分析
    优点：在一定程度上对数组存储方式有优化，比如：插入一个数值节点，只需要将该节点链接到  
    链表中即可，删除效率也很好。
    缺点：在进行检索时，效率任然比较低，比如检索某个值需要从头节点开始遍历。
3. 树存储方式的分析
    能提高数据存储、读取的效率，比如利用**二叉排序树(Binary Sort Tree)**，既可以保证  
    数据的检索速度，同时也可以保证数据的插入，删除，修改的速度。

### 二叉树

遍历方式：
    前序：父、左、右。中序：左、父、右。后序：左、右、父

### 顺序存储二叉树
- 数组存储方式和树的存储方式可以相互转换
- 顺序存储二叉树通常只考虑完全二叉树(n表示二叉树的第几个元素，从0开始)
  1. 第n个元素的左子节点为2*n+1
  2. 第n个元素的右子节点为2*n+2
  3. 第n个元素的父节点为(n-1)/2
- 应用实例：堆排序

### 线索化二叉树
- n个节点的二叉链表中含有n+1个空指针域。利用空指针域存放指向该节点在某种遍历次序下的前驱和后继点的指针  
  (这种附加的指针称为“线索”)
- 这种加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树(Threaded BinaryTree)。根据线索性  
  质不同，可分为前序线索二叉树、中序线索二叉树、后序线索二叉树三种
- 一个节点的前一个节点称为前驱节点，后一个称为后继节点
- 线索化之后，不能再使用原来的方式遍历。同过线性方式遍历，提高了遍历的效率，新的遍历方式和线索化之前的次序相同。

## 图

- 常用概念：顶点，边，路径，无向图(没有方向)，有向图，带权图(边带有权值，这种图也叫做网)
- 图的表示方式：二维数组(邻接矩阵)，链表(邻接表)

### 深度优先遍历(Depth First Search) ---DFS

- 从初始访问节点出发，初始访问节点可能有多个邻接节点，深度优先遍历的策略是首先访问第一个邻接节点，然后再以这个  
  被访问的邻接节点作为初始节点，访问它的第一个邻接节点，可以如此理解：每次都在访问完当前节点后首先访问当前节点  
  的第一个邻接节点
- 这样的访问策略是优先往纵向挖掘深入，而不是对一个节点的所有邻接节点进行横向访问
- 深度优先搜索是一个递归的过程

### 广度优先遍历(Broad First Search) ---BFS

- 类似一个分层搜索的过程，使用一个队列保持访问过的节点的顺序，以便按这个顺序来访问这些节点的邻接节点
- 算法步骤：
  1. 访问初始节点v并标记节点v为已访问
  2. 节点v入队列
  3. 当队列非空时，继续执行，否则算法结束
  4. 出队列，取得队头节点u
  5. 查找u的第一个邻接节点w
  6. 若u的邻接节点w不存在则转到步骤3，否则循环以下步骤：
    - 若节点未被访问，则访问节点w并标记为已访问
    - 节点w入队列
    - 查找节点u的继w邻接节点后的下一个邻接节点，转到步骤6

